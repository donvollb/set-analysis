---
output:                             
  pdf_document:                     
    latex_engine: xelatex
editor_options:                     
  chunk_output_type: console
header-includes:
  # Hier werden verschiedene Pakete für LATEX geladen
- \usepackage{fancyhdr}             # für Kopf- und Fußzeile
- \usepackage{graphicx}             # für das Einbinden von Graphiken
- \usepackage{eurosym}              # für Eurosymbole
- \usepackage{booktabs}             # für zusätzliche Stilelemente in Tabellen
- \usepackage{xcolor}               # für Farben
- \usepackage{tabu}                 # für Tabellen, die über mehrere Seiten gehen
- \usepackage{tabto}                # für Tabs
- \usepackage{makecell}             # für Layouts in Tabellen
- \usepackage{longtable}            # für Tabellen über mehrere Seiten
- \usepackage{array}                # ebenfalls Tabellenlayout/Matritzen 
- \usepackage{multirow}             # für Tabellen mit mehrzeiligen Zellen
- \usepackage{wrapfig}              # für Bilder und Tabellen, die von text umschlossen werden
- \usepackage{float}                # für Abbildungen/Tabellen
- \usepackage{colortbl}             # für farbige Zeilen/Spalten in Tabellen
- \usepackage{pdflscape}            # für mögliche Rotation der Seiten
- \usepackage{threeparttable}       # für Titel/Anmerkungen von Tabellen
- \usepackage[normalem]{ulem}       # für Unterstriche
- \usepackage{fontspec}             # für Schriftarten
- \usepackage{hyperref}             # für Hyperlinks
- \usepackage{geometry}             # für Seitenränder
- \usepackage{tocloft}              # für Inhaltsverzeichnismodifikationen
  # Ab hier wird das Layout der Seitenränder definiert
- \geometry{
- a4paper,                          # Seitengröße
- left = 2cm,                       # Abstand links
- right = 2cm,                      # Abstand rechts
- headheight = 2cm,                 # Höhe Kopfzeile
- top = 3cm,                        # Abstand Seiteninhalt nach oben (unabhängig von Kopfzeile)
- bottom = 2cm,                     # Abstand Seiteninhalt nach unten (unabhängig von Fußzeile)
- footskip = 1.5cm}                 # Höhe Fußzeile
  # Ab hier beginnt das Setup für die Hyperlinks
- \hypersetup{
- colorlinks=true,                  # farbige Links?
- linkcolor=blue,                   # Farbe der Hyperlinks zu Abschnitten innerhalb des Dokuments
- filecolor=magenta,                # Farbe von Hyperlinks zu Dateien
- urlcolor=cyan}                    # Farbe von URLs
  # Hier wird die Schriftart aus dem rmd-data Ordner geladen
- \setmainfont[
- Path = rmd-data/Raleway/ ,          # Pfad, wo Schrifart liegt
- UprightFont = Raleway-Regular,      # Dateiname reguläre Schrift
- BoldFont = Raleway-Bold ,           # Dateiname fette Schrift
- ItalicFont = Raleway-LightItalic ,  # Dateiname kursive Schrift
- Extension = .ttf]{Raleway}          # Dateiendungen
  # Hier wird noch das Inhaltsverzeichnis ein wenig zurechtgestutzt
- \renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}} # Punkte zwischen Eintrag und Seite auch bei "Sections" (erste Überschriftsebene)
- \renewcommand\cftsecfont{\mdseries}                   # Einträge bei "Sections" werden nicht fett geschrieben
- \renewcommand\cftsecpagefont{\mdseries}               # Seitenzahlen bei "Sections" werden nicht fett geschrieben
- \setlength{\cftsecindent}{1.5em}                      # Einträge im Inhaltsverzeichnis leicht eingerückt
  # Hier werden einige Farben für die Verwendung im LATEX-Code definiert
- \definecolor{uniblau2}{RGB}{7, 63, 139}           # "uniblau" über RGB
- \definecolor{uniblau}{HTML}{073F8B}               # "uniblau" über html
- \definecolor{darkgrey}{RGB}{200, 200, 200}        # Dunkelgrau für manche Beschriftungen
- \definecolor{tablecolor}{RGB}{250, 230, 255}      # Tabellenfarbe im Dokument, jeweils ändern
- \definecolor{tablecolorShowUp}{RGB}{234,248,255}  # Tabellenfarbe ShowUp
- \definecolor{tablecolorSTUD}{RGB}{234,255,212}    # Tabellenfarbe STUD
- \definecolor{tablecolorABS}{RGB}{250, 230, 255}   # Tabellenfarbe ABS
- \definecolor{tablecolorLVE}{RGB}{228, 253, 255}   # Tabellenfarbe LVE
- \definecolor{cadetblue4}{RGB}{83,134,139}         # Schriftfarbe LVE
- \definecolor{steelblue}{RGB}{70,130,180}          # Schriftfarbe steelblue
---

```{r Setup, include=FALSE}
### Unten links befindet sich der Dropdown navigator. Hiermit kannst du zwischen den Chunks und Überschriften switchen

# Oben im YAML bei "\definecolor{tablecolor}{RGB}{234,255,212}" die Werte in der geschweiften Klammer durch die richtige Farbe (siehe andere Farben) ersetzen


# ÄÖU richtig angezeigt? (Reopen with Encoding: UTF-8)

# FUNKTION DES CHUNKS:
# Pakete laden, Golbale Variablen setzen und Datensätze/Funktionsdatei einlesen



#### A - PAKETE ####
#Mit der Pacman-Funktion werden die nötigen Pakete geladen und fehlende installiert. Bei Bedarf wird sie erweitert
suppressPackageStartupMessages(if(!require(pacman)){install.packages("pacman")})
pacman::p_load(dplyr, # Datenselektion
               tidyverse, # Datenselektion
               ggplot2, # Graphen
               rgdal, # Brauchen wir das noch?
               Hmisc, # labels
               R6, # Objektorientiertes Programmieren, brauchen wir das noch?
               extrafont, # Schriftarten
               Cairo, # Für pdfs
               sjlabelled, # Für label-managemant
               kableExtra, # Für pdf-Tabellen
               DescTools, # Für statistische Analysen
               showtext # Für Schriftart
               ) 


#### B - GLOBALE VARIABLEN ####

##### 1. Variable #####

###### Protokollvariable (nicht ändern, muss hier oben stehen!)
# Falls i existiert, was nur bei der AUtomatisierungsscheleife der Fall ist, wird das Protokoll mitgeschrieben
inkl.protokoll <- ifelse(exists("i"), TRUE, FALSE)

###### Modifizierbare Werte ######

# i Variable
  if(!exists("i")) {i <- 3} 
     # i beim Testen für den jeweiligen Bericht einstellen
     # i gibt die Zeile der personalized_info Datei an und steht für einen Bericht


# Campus
  if(!exists("campus")) {campus <- "KO"}
  # Zum Testen einstellen, je nach dem werden die entsprechenden Daten eingelesen


# Berichtart Variable -> # LVE, ABS, STUD, SHOWUP? 
  bericht <- "STUD"
      # Um welchen Bericht handelt es sich? # Diese Variable wird gewählt um bspw. das Farbchema zu setzten
      # WICHTIG: Einhalten der Abkürzung!
  
  
# Kurztitel der Umfrage (für Fußzeile im Bericht)
  lfoot <- "Studierendenbefragung ZFUW Frühjahr 2021"
  
  
  
  
###### Nicht-modifizierbare Werte (nur mit Bedacht ändern) ######


# anchor Variable für offene Variablen
  anchor.nr <- 0
       # Die anchor Vairable dient zu erstellen von Hyperlinksvon offenen Fragen
  
# Environment für offene Fragen
  list.open <- new.env()
       # In die Environment werden offene Fragen gepackt
  
# Sub-Chunks Nummer
  sub.nr <- 0 # Für die fortlaufenden Titel der Subchunks, NICHT ÄNDERN!

  
  
  
##### 2. Farbsetting #####

  
#Farbe der Balken/Text, unbedingt einstellen! -> automatisiert

if (bericht == "LVE"){color.bars <- "cadetblue4"} 
if (bericht == "ABS"){color.bars <- "plum4"}
if (bericht == "STUD"){color.bars <- "darkseagreen"}
if (bericht == "SHOWUP"){color.bars <- rgb(109, 172, 220, maxColorValue = 255)}

  

##### 3. Einstellungen zu Grafiken #####
show.plot.mc <- FALSE # Sollen die Plots der MC-Fragen angezeigt werden?
show.plot.sc <- FALSE # Sollen die Plots der SC-Fragen angezeigt werden?
show.plot.sk <- TRUE  # Sollen die Plots der SK-Fragen angezeigt werden?



##### 4. Chunk Einstellungen ####

knitr::opts_chunk$set(
	comment = "",
	dev = "cairo_pdf",
	results = "asis",
	echo = FALSE,
	warning = FALSE,
	message = FALSE
)


##### 5. Auswahl der Schriftart ####
if (!("Raleway" %in% showtextdb::font_installed())) {showtextdb::font_install(showtextdb::google_fonts("Raleway"))}
showtext::showtext_auto()

# Beim ersten Mal auf einem neuen Computer: 
# extrafont::font_import(paths = "./rmd-data/Raleway/") 
# Schriftart Raleway wird importiert
# extrafont::loadfonts(device="win") # Schriftart wird geladen


par(family = "Raleway") # Grafik Einstelungen auf Raleway ändern
opar <- par() #Diese abspeichern




#### C - DATENSÄTZE UND FUNKTIONEN LADEN ####

# Daten einlesen
if (campus== "KO") {
    load(file="Daten/KO.Daten_STUD_2021.rda")} else {load(file="Daten/LD.Daten_STUD_2021.rda")}

# Individuelle Info für Einzelberichte
#personalized_info <- read.csv2("Tabellen/KO_STUD_2021.csv")
if (campus== "KO") {
  personalized_info <- read.csv2("Tabellen/KO_STUD_2021.csv")} else {
    personalized_info <- read.csv2("Tabellen/LD_STUD_2021.csv")}

if (campus== "KO") {data <- data.ko} else {data <- data.ld}


# Funktionen laden
source("Test_Ordner/Funktionen_LE_all_v.1.0.1.R", encoding = "UTF-8")


```

[//1]: Das hier ist ein Kommentar und wird nicht im finalen Dokument angezeigt.

[//2]: Stil des Dokuments
\pagestyle{fancy}
\fancyhf{}

```{r campus ueberschrift}
# FUNKTION DES CHUNKS:
# Jeweils für KO und LD den Header abändern

if(personalized_info$Campus[i] == "LD") { # Wenn es um einen Landauer Bericht geht
  
  # Nehme das MeZe Logo
  cat("\\rhead{\\includegraphics[height=1.2cm]{rmd-data/meze-logo.png}}") 
  
  } else { 
    # Ansonsten schreibe für KO "BÜRO FÜR EVALUATION..."
    cat("\\rhead{\\color{darkgray}{BÜRO FÜR EVALUATION IN STUDIUM \\& LEHRE |\\\\
      LEHREVALUATION KOBLENZ}}")
    }
```

[//4]: Universitätslogo wird eingefügt
\lhead{\includegraphics[width=6cm]{rmd-data/uni-logo-farbig.eps}}

[//5]: Horizontale Trennstriche
\renewcommand{\headrulewidth}{1pt}
\renewcommand{\headrule}{\hbox to\headwidth{%
    \color{uniblau}\leaders\hrule height \headrulewidth\hfill}}
    
\renewcommand{\footrulewidth}{1pt}
\renewcommand{\footrule}{\hbox to\headwidth{%
    \color{uniblau}\leaders\hrule height \footrulewidth\hfill}}
    
[//6]: Fußzeile
\rfoot{\color{darkgray}{Seite \thepage}}

[//7]: In der nächsten Zeile wird der Kurztitel der Umfrage eingefügt (weiter oben definiert)
\lfoot{\color{darkgray}{`r lfoot`}}


```{r inkl Variablen, include=FALSE}
# FUNKTION DES CHUNKS

#### inkl.-Variablen einlesen ####

# Für inkl.open -> Transformation von "x" in TRUE/FALSE
if ("inkl.open" %in% colnames(personalized_info)) {
  
  personalized_info$inkl.open[is.na(personalized_info$inkl.open)] <- FALSE
  personalized_info$inkl.open[personalized_info$inkl.open == ""] <- FALSE
  personalized_info$inkl.open[personalized_info$inkl.open == "x"] <- TRUE
}


# Namen der inkl. Variablen und header definierten
names.inkl <- names(dplyr::select(personalized_info, dplyr::starts_with("inkl."), dplyr::starts_with("header"))) # Namen der Header und inkl. einlesen


for (n in 1:length(names.inkl)) { # Für jeden der Namen
  
  x <- names.inkl[n] # Speichere den Namen ab
  if(personalized_info[i, x] == "TRUE") { assign(as.character(x), TRUE) } else { assign(as.character(x), FALSE) } 
  #Falls in der jeweiligen Zeile "TRUE" steht, also die Frage vorkommen soll, setze die inkl. Variable auf TRUE (ansonsten FALSE)
}

rm(n, x, names.inkl)

```


```{r Daten editieren}
# FUNKTION DES CHUNKS:
# Falls Daten editiert werden müssen oder Namen unkenntlich gemacht werden müssen 
# Wenn etwa ein Variablenname im Nachhinein geändert werden muss

#### A - Daten editieren ####


#### B - Namen unkenntlich machen ####

# Beispiel
# data[, 68] <- gsub("Fr. Ulitsch", "-[Name gelöscht]-", data[, 68])
```


```{r Titel und Stichprobe, include = FALSE}
# FUNKTION DES CHUNKS:
# Titel und Stichprobenbeschreibung aus personalized info ziehen

Titel <- as.character(personalized_info$Titel[i]) #Titel speichern
Stichprobe <- as.character(personalized_info$Stichprobe_Text[i]) #Stichprobentext speichern
```


```{r Daten filtern, include = FALSE}
# FUNKTION DES CHUNKS:
# Daten je nach Stichprobe filtern 
# Muss je nach Befragung stark abgeändert werden
# Bei ZFUW-STUD müssen z.B. auch Sub-Datensätze erstellt werden

# Bei der Selektion können die Labels verloren gehen, daher am besten am Anfang:
# Kopie mit Labels ablegen
data_copy <- data



# Am Ende des Chunks: Labels zurückkopieren
data <- sjlabelled::copy_labels(data, data_copy)
# Kopie entfernen
rm(data_copy)
```


```{r Protokoll, eval = inkl.protokoll}
# FUNKTION DES CHUNKS
# Protokoll überschreiben 
if (campus == "KO") {
  protokoll <- read.csv2("Tabellen/KO_Berichte_Protokoll_STUD_2021.csv") # diese Datei wurde im Skript "Automatisierung" erstellt
  protokoll$N[i] <- nrow(data) # Anzahl der Personen dokumentieren
  write.csv2(protokoll, # die Datei wieder speichern
           file = "Tabellen/KO_Berichte_Protokoll_STUD_2021.csv", 
           row.names = FALSE) 
  
} else {
  protokoll <- read.csv2("Tabellen/LD_Berichte_Protokoll_STUD_2021.csv") # diese Datei wurde im Skript "Automatisierung" erstellt
  protokoll$N[i] <- nrow(data) # Anzahl der Personen dokumentieren
  write.csv2(protokoll, # die Datei wieder speichern
           file = "Tabellen/LD_Berichte_Protokoll_STUD_2021.csv", 
           row.names = FALSE) 
}
```

[//8]: Titel wird geschrieben
\begin{LARGE}
\begin{center}
\textbf{`r Titel`}
\end{center}
\end{LARGE}


```{r Abrruch Schleife, message=FALSE, warning=FALSE, include=FALSE}

# FUNKTION DES CHUNKS
# Abbrechen der Knit-Schleife bei zu kleinen Stichproben

# Erst nach dem Titel einfügen, da eine leere Seite nicht geknittet werden kann!

# wenn N<10, knitten abbrechen
# das pdf wird trotzdem erstellt (knitten geht insgesamt schneller)

if(nrow(data) < 10){

  cat("*Dieser Bericht wurde nicht erstellt, da die Substichprobe weniger als zehn Personen beinhaltet.**") # Platzhalter, nochmal überarbeiten
  knitr::knit_exit()

}

```

```{r Setup Erste Seite}

# FUNKTION DES CHUNKS:

# Nutzen, falls Vorbereitungen zum Anzeigen der Stichprobe auf der ersten Seite erfolgen müssen

#### Variablen ####

# Befragungszeitraum
bef.zeit <- "01.01.1970 - 12.12.2070"

# Befragungsart definieren (für erste Seite)
bef.art <- "Online-Umfrage (via Losungs-Verfahren)"

# Rücklauf
# Eventuell je nach Bericht ändern lassen
ruecklauf <- ifelse(campus == "KO", 
                    "Es wurden xxx Koblenzer Studierende aus dem x. und x. Semester eingeladen; xxx (xx%) nahmen teil.",
                    "Es wurden xxx Landauer Studierende aus dem x. und x. Semester eingeladen; xxx (xx%) nahmen teil.")

# Anzahl Stimmen im Bericht
# Normalerweise Länge des Datensatzes
stg_ges <- nrow(data)
```

[//9]: vspace steht für vertical space, also vertikalen Abstand

\vspace{10mm}

[//10]: Überschrift für erste Seite (nicht der Titel!)

\addtocontents{toc}{\vspace{0.2cm}}

# Angaben zur Befragung und zur Stichprobengröße

\vspace{6mm}

\textbf{Befragungszeitraum} `r bef.zeit` 
\vspace{6mm}

\textbf{Art der Befragung:} `r bef.art`
\vspace{6mm}

\textbf{Stichprobenbeschreibung:}  `r Stichprobe` 
\vspace{6mm}

\textbf{Rücklauf:} `r ruecklauf`
\vspace{6mm}

\textbf{Anzahl an Stimmen in diesem Bericht:} `r stg_ges`
\vspace{14mm}

\color{darkgray}\hrule

\color{black}
\vspace{11mm}

\textit{Hinweis: Die Zuordnung zur Stichprobe dieses Ergebnisberichts ergibt sich aus den Angaben der Umfragenteilnehmenden.}

\pagebreak

### Legende zu den deskriptiven Statistiken und Säulendiagrammen

```{r Vorbereitung_Legende}
# FUNKTION DES CHUNKS
# Chunk für Legenden

print(bsp.table.stat())

cat("  \n  \n")

bsp.evasys.sk6()

```


### Legende zu den Häufigkeitstabellen
 - *"Häufigkeit"* absolute Häufigkeit 
 - *"Prozent / %"* prozentuale Häufigkeit, bezieht sich auf alle Werte inkl. der fehlenden Werte
 - *"gültige %"*  gültige Prozent, hier sind fehlende Werte von der Berechnung ausgeschlossen
 - *"NAs"* steht für fehlende Werte bzw. keine Angabe.

### Zusätzliche Hinweise
- Bei Fragen, die mit *eckigen Klammertermen beginnen*, handelt es sich um Filterfragen: je nach vorheriger Angabe also für die Teilnehmer der Online-Umfrage nicht sichtbar (~ kumulierte Prozent also potentiell <100).

- Manche Fragen wurden im *Multiple-Choice-Format* (Mehrfachnennung möglich) programmiert, können also Mehrfachantworten erhalten (~ kumulierte Prozent also potentiell >100).


[//11]: pagebreak bedeutet Neue Seite
\pagebreak

[//12]: Erstellung Inhaltsverzeichnis
\setcounter{tocdepth}{2}
\renewcommand*\contentsname{INHALTSVERZEICHNIS}
\begingroup
\hypersetup{linkcolor=black}
\tableofcontents
\thispagestyle{fancy}
\endgroup

\pagebreak 

```{r header2}
# Ab hier kommen Chunks mit Fragen

# Falls nicht jeder header in jeder Umfrage: oben 
# eval = headerx (x ist die Zahl des headers) einfügen 
# (header-Varibale muss dazu in personalozed info stehen)

# Überschrift Beispiel:
# Das "  \n  \n" am Ende sorgt für Umbrüche und Zurücksetzen der Formatierung
cat("# 2. Allgemeine Angaben  \n  \n")

# Ab hier Auswertung, nach Muster einfügen

merge.sc(data$studgang, nr = "2.1")

merge.num(data$fachsem, nr = "2.4", xlab = "Fachsemester", cutoff = 12)

merge.mc(dplyr::select(data, module_AUW_A:module_AUW_O), nr = "4.1", inkl = TRUE)

open.answers(data$WL_3, nr = "29.3")


# Am Ende Seitenumbruch
cat("\\pagebreak  \n  \n")

```


```{r header.open}
# Chunk für offene Fragen, kann so bleiben. 

if (anchor.nr != 0)  { # anchor.nr wird ungleich 0, wenn offene Fragen vorkommen
  
  cat("# Anhang: Fragen mit offenem Antwortformat  \n  \n")

  for (k in 1:anchor.nr) {
    x <- eval(parse(text = paste0("list.open$var.", k)))
    q.nr <- eval(parse(text = paste0("list.open$nr.", k)))
    merge.open(x, nr = q.nr, anchor = k, inkl = eval(parse(text = paste0("inkl.", q.nr))))}
  rm(anchor.nr, q.nr)
}

```
